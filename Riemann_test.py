from math import*
import numpy as np

class Riemann ():
    def __init__ (self, n_cell, l, disc, gamma, timeout, rho_inf, rho_sup, P_inf,P_sup, v_inf, v_sup):
        self.n_cell == n_cell
        self.l = l
        self.disc = disc
        self.gamma = gamma
        self.timeout = timeout
        self.rho_inf = rho_inf
        self.rho_sup = rho_sup
        self.P_inf = P_inf
        self.P_sup = P_sup
        self.u_inf = v_inf
        self.u_sup = v_sup

        self.G1 = (gamma-1)/(2*gamma)
        self.G2 = (gamma+1)/(2*gamma)
        self.G3 = 2*gamma/(gamma-1)
        self.G4 = 2/(gamma-1)
        self.G5 = 2/(gamma+1)
        self.G6 = (gamma-1)/(gamma+1)
        self.G7 = (gamma-1)/2
        self.G8 = gamma-1

        self.CL = sqrt(self.gamma*self.P_inf/self.rho_inf)
        self.CR = sqrt(self.gamma*self.P_sup/self.rho_sup)

        if self.G4*(self.CL+self.CR) <= self.v_sup-self.v_inf :
            return "Vacuum generated by data"

    def Starpu (self, P, U, MPA):
        pass

    def Guessp (self):
        self.QUSER = 2

        self.CUP = 0.25*(self.DL+self.DR)*(self.CL+self.CR)
        self.PPV = max(0, 0.5*(self.PL+self.PR)+0.5*(self.UL-self.UR)*self.CUP)
        self.PMIN = min(self.P_inf, self.P_sup)
        self.PMAX = max(self.P_inf, self.P_sup)
        self.QMAX = self.PMAX / self.PMIN

        if self.QMAX <= self.QUSER and self.PMIN <= self.PPV and self.PPV <= self.PMAX :
            self.PM = self.PPV
        else :
            if self.PPV < self.PMIN :
                self.PQ = (self.P_inf/self.P_sup)**self.G1
                self.UM = (self.PQ*self.u_inf/self.CL + self.u_sup/self.CR + self.G4*(self.PQ-1))/(self.PQ/self.CL+1./self.CR)
                self.PTL = 1+self.G7*(self.u_inf - self.UM)/self.CL
                self.PTR = 1+self.G7*(self.UM - self.u_sup)/self.CL
                self.PM = 0.5*(self.P_inf*self.PTL**self.G6 + self.PR*self.PTR**self.G3)
            else: 
                self.GEL = sqrt((self.G5/self.rho_inf)/(self.G6*self.P_inf + self.PPV))
                self.GER = sqrt((self.G5/self.rho_sup)/(self.G6*self.P_sup + self.PPV))
                self.PM = (self.GEL*self.P_inf + self.GER*self.PR - (self.u_sup - self.u_inf)) / (self.GEL+self.GER)

        return self.PM

    def Prefun (self, F, FD, P, DK, PK, CK) :
        if P <= PK :
            self.PRAT = P/PK
            self.F = self.G4 * CK *(self.PRAT**self.G1 -1)
            self.FD = (1./(DK*CK))*self.PRAT**(-1 * self.G2)
        else :
            self.AK = self.G5/DK
            self.BK = self.G6*PK
            self.QRT = sqrt(self.AK/(self.BK+P))
            self.F = (P - PK)*self.QRT
            self.FD = (1 - 0.5*(P-PK)/(self.BK+P))*QRT

        return self.FD

    def Sample (self, PM, UM, S, D , U, P):
        if S <= UM :

            if self.PM <= self.P_inf :

                self.SHL = self.u_inf - self.CL     


                if S <= self.SHL :
                    D = self.rho_inf  
                    U = self.u_inf
                    P = self.P_inf
                else :
                    self.CML = self.CL *(self.P_sup/self.P_inf)**self.G1
                    self.STL = self.UM -self.CML

                    if S >= self.STL :
                        D = self.rho_inf *(self.PM/self.PL)**(1/self.gamma)
                        U = self.UM
                        P = self.PM
                    
                    else :
                        U = self.G5 *(self.CL +self.G7*self.u_inf + S)
                        C = self.G5*(self.CL +self.G7*(self.u_inf -S ))
                        D = self.rho_inf * (C/self.CL)**self.G4
                        P = self.P_inf*(C/self.CL)**self.G3
            else :
                self.PML = self.PM / self.P_inf
                self.SL = self.u_inf - self.CL * sqrt(self.G2 *self.PML + self.G1)

                if S <= self.SL :
                    D = self.rho_inf
                    U = self.u_inf
                    P = self.P_inf

                else : 
                    D = self.rho_inf*(self.PML + self.G6)/(self.PML*self.G6 + 1)
                    U = self.UM
                    P = self.PM
        else :
            if self.PM > self.P_sup :
                self.PMR = self.PM/self.P_sup
                self.SR = self.u_sup + self.CR *sqrt(self.G2*self.PMR+self.G1)

                if S >= self.SR :
                    D = self.rho_sup
                    U = self.u_sup
                    P = self.P_sup
                else :
                    D = self.rho_sup*(self.PMR+self.G6)/(self.PMR*self.G6+1)
                    U = self.UM
                    P = self.PM
            else :
                
                




