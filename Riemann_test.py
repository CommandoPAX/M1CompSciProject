from math import*
import numpy as np

class Riemann ():
    def __init__ (self, n_cell, l, disc, gamma, timeout, rho_inf, rho_sup, P_inf,P_sup, v_inf, v_sup):
        self.n_cell == n_cell
        self.l = l
        self.disc = disc
        self.gamma = gamma
        self.timeout = timeout
        self.rho_inf = rho_inf
        self.rho_sup = rho_sup
        self.P_inf = P_inf
        self.P_sup = P_sup
        self.u_inf = v_inf
        self.u_sup = v_sup

        self.G1 = (gamma-1)/(2*gamma)
        self.G2 = (gamma+1)/(2*gamma)
        self.G3 = 2*gamma/(gamma-1)
        self.G4 = 2/(gamma-1)
        self.G5 = 2/(gamma+1)
        self.G6 = (gamma-1)/(gamma+1)
        self.G7 = (gamma-1)/2
        self.G8 = gamma-1

        self.CL = sqrt(self.gamma*self.P_inf/self.rho_inf)
        self.CR = sqrt(self.gamma*self.P_sup/self.rho_sup)

        if self.G4*(self.CL+self.CR) <= self.v_sup-self.v_inf :
            return "Vacuum generated by data"

    def Starpu (self, P, U, MPA):
        self.Pold = self.Guessp()
        self.Udiff = self.u_sup - self.u_inf

        self.Tolpre = 1e-6
        Nriter = 20

        for i in range(1, Nriter):
            FL, FLD = self.Prefun(self.Pold, self.rho_inf, self.P_inf, self.CL)
            FR, FRD = self.Prefun(self.Pold, self.rho_sup, self.P_sup, self.CR)

            P = self.Pold - (FL + FR +self.Udiff)/(FLD+FRD)
            change = 2* abs((P-self.Pold)/(P+self.Pold))

            if change <= self.Tolpre :
                pass
            else :
                if P < 0 :
                    P = self.Tolpre
                    self.Pold = P


    def Guessp (self):
        self.QUSER = 2

        self.CUP = 0.25*(self.DL+self.DR)*(self.CL+self.CR)
        self.PPV = max(0, 0.5*(self.PL+self.PR)+0.5*(self.UL-self.UR)*self.CUP)
        PMIN = min(self.P_inf, self.P_sup)
        PMAX = max(self.P_inf, self.P_sup)
        self.QMAX = PMAX / PMIN

        if self.QMAX <= self.QUSER and PMIN <= self.PPV and self.PPV <= PMAX :
            PM = self.PPV
        else :
            if self.PPV < PMIN :
                self.PQ = (self.P_inf/self.P_sup)**self.G1
                UM = (self.PQ*self.u_inf/self.CL + self.u_sup/self.CR + self.G4*(self.PQ-1))/(self.PQ/self.CL+1./self.CR)
                self.PTL = 1+self.G7*(self.u_inf - UM)/self.CL
                self.PTR = 1+self.G7*(UM - self.u_sup)/self.CL
                PM = 0.5*(self.P_inf*self.PTL**self.G6 + self.PR*self.PTR**self.G3)
            else: 
                self.GEL = sqrt((self.G5/self.rho_inf)/(self.G6*self.P_inf + self.PPV))
                self.GER = sqrt((self.G5/self.rho_sup)/(self.G6*self.P_sup + self.PPV))
                PM = (self.GEL*self.P_inf + self.GER*self.PR - (self.u_sup - self.u_inf)) / (self.GEL+self.GER)

        return PM

    def Prefun (self, P, DK, PK, CK) :
        if P <= PK :
            self.PRAT = P/PK
            F = self.G4 * CK *(self.PRAT**self.G1 -1)
            FD = (1./(DK*CK))*self.PRAT**(-1 * self.G2)
        else :
            self.AK = self.G5/DK
            self.BK = self.G6*PK
            self.QRT = sqrt(self.AK/(self.BK+P))
            F = (P - PK)*self.QRT
            FD = (1 - 0.5*(P-PK)/(self.BK+P))*self.QRT

        return F, FD

    def Sample (self, PM, UM, S, D , U, P):

        if S <= UM :

            if PM <= self.P_inf :

                self.SHL = self.u_inf - self.CL     


                if S <= self.SHL :
                    D = self.rho_inf  
                    U = self.u_inf
                    P = self.P_inf
                else :
                    self.CML = self.CL *(self.P_sup/self.P_inf)**self.G1
                    self.STL = UM -self.CML

                    if S >= self.STL :
                        D = self.rho_inf *(PM/self.PL)**(1/self.gamma)
                        U = UM
                        P = PM
                    
                    else :
                        U = self.G5 *(self.CL +self.G7*self.u_inf + S)
                        C = self.G5*(self.CL +self.G7*(self.u_inf -S ))
                        D = self.rho_inf * (C/self.CL)**self.G4
                        P = self.P_inf*(C/self.CL)**self.G3
            else :
                PML = PM / self.P_inf
                self.SL = self.u_inf - self.CL * sqrt(self.G2 *PML + self.G1)

                if S <= self.SL :
                    D = self.rho_inf
                    U = self.u_inf
                    P = self.P_inf

                else : 
                    D = self.rho_inf*(PML + self.G6)/(PML*self.G6 + 1)
                    U = UM
                    P = PM
        else :
            if PM > self.P_sup :
                PMR = PM/self.P_sup
                self.SR = self.u_sup + self.CR *sqrt(self.G2*PMR+self.G1)

                if S >= self.SR :
                    D = self.rho_sup
                    U = self.u_sup
                    P = self.P_sup
                else :
                    D = self.rho_sup*(PMR+self.G6)/(PMR*self.G6+1)
                    U = UM
                    P = PM
            else :
                self.SHR = self.u_sup + self.CR

                if S >= self.SR :
                    D = self.rho_sup
                    U = self.u_sup
                    P = self.P_sup
                else:            
                    self.CMR = self.CR * (PM / self.P_sup)**self.G1
                    self.STR = UM + self.CMR

                    if S <= self.STR :
                        D = self.rho_sup*(PM/self.P_sup)**(1/self.gamma)
                        U = UM
                        P = PM    
                    else :
                        U = self.G5*(-1*self.CR + self.G7*self.u_sup + S)
                        C = self.G5 *(self.CR-self.G7*(self.u_sup -S))
                        D = self.rho_sup*(C/self.CR)**self.G4
                        P = self.P_sup*(C/self.CR)**self.G3



        return D, U, P




